// Package task_322
// 322. Coin Change
package task_322

// coinChange
// Решение из интернета
// Сложность по времени O(amount*len(coins)), по памяти O(amount).
// Идея в том, чтобы использовать паттерн dynamic programming (bottomUp).
// Нужно создать массив - индекс - сумма, значение - сколько монет нужно для набора этой суммы.
// Для суммы 0 нужно 0 монет.
// Для каждой суммы от 1 до amount посчитать, сколько нужно монет.
// Для суммы 1 нужно пройтись по всем монетам и найти монету равную 1.
// Для суммы 2 нужно пройтись по всем монетам и найти монету равную двум или 1+1.
// Если была монета 1, то берем разницу a-c=1 и берем dp[1].
// Таким образом, вычисляется для всех сумм сколько нужно монет.
// Решая подзадачи, будет в итоге решена главная задача с суммой amount.
func coinChange(coins []int, amount int) int {
	dp := make([]int, amount+1) // для каждой суммы (индекс) кол-во монет (значение)
	defaultValue := amount + 1
	for i := range dp {
		dp[i] = defaultValue // макс значение. Далее будет браться минимум.
	}
	dp[0] = 0 // для суммы 0 нужно 0 монет
	for a := 1; a <= amount; a++ {
		for _, c := range coins {
			if c > a { // если монета больше искомой суммы, то она не подходит
				continue
			}

			dp[a] = min(dp[a], 1+dp[a-c]) // значение от меньшей суммы, ранее вычисленной
		}
	}

	if val := dp[amount]; val != defaultValue {
		return val
	} else {
		return -1
	}
}
